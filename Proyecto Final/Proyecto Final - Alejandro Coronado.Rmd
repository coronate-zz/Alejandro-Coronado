---
title: "Mineria de Datos - Proyecto Final"
author: "Alejandro Coronado"
date: "17 de noviembre de 2016"
output: html_document
---

library('ggplot2')
library('ggplot2')

#Proyecto Final 
Resolver los ejercicios vistos en clase.

##Análisis Descriptivo

En esta seccin se resuelven algunos probelmas que se presnetan cuando limpiamos bases de datos y queremos hacer uns descripcion de las relacion entre nuestras variables.

* GGplot
* German Data Set
* Algas Data Set
* Berka
* XXX

***

##GGplot 

Cargando Librerias:
```{r, nclude=FALSE, cache=FALSE, warning=FALSE, eval=FALSE }

 library('lubridate')
 library( 'magrittr')
 library( 'ggvis')
 library( 'dplyr')
 library( 'tidyr')
 library( 'readr')
 library('rvest')
 library( 'ggplot2')
 library('stringr')
 library('ggthemes')
 library('googleVis')
 library('shiny')
 library( 'tibble')
 library( 'vcd')
 library('vcdExtra')
 library( 'GGally')
 library( 'readODS')
#library( 'readxl')
 library("RSQLite" )
 library('ggplot2movies')

```

###Boston Data Set

**Ejercicio 1**

1. Grafica `medv` usando `boxplot`, `stripchart` (*jittered dotplot*), `stem`, `density` estimate con  `rug` plot

```{r}


p<-ggplot(MASS::Boston, aes(medv)) 

p + geom_histogram() + ylab("") + xlab("Valor medio de las casas (1000s USD)")
#Density Chart con Rug
p +  geom_density() + geom_rug()+  ylab("") + xlab("Valor medio de las casas (1000s USD)")
#Stem chart
p +  geom_bar() + ylab("") + xlab("Valor medio de las casas (1000s USD)")


#Boxplot
p<-ggplot(MASS::Boston, aes( 'Valor medio de las casas', medv ))
p +  geom_boxplot() + ylab("") + xlab("Valor medio de las casas (1000s USD)")
#Stripchart
p +  geom_jitter() + ylab("") + xlab("Valor medio de las casas (1000s USD)")



```



¿Qué observas en cada una de estas gráficas?
* La primera grafica geom_histogram nos da una idea de las distribucion del valor medio de las casas en el dataSet. Vemos que la mayor concentración de precios esta en 20,000 dolares.
* Geom_density confirma la distribución del valor medio de las casas y vemos que estos precios se comportan casi como una distribución normal
* geom_bar es similar a geom_histogram pero ahora los datos no se encuentran agrupados en intervalos sino que cada uno es represnetado por su propio valor.
* geom_boxplot Nos muestra que la media de los datos esta en 20,000 dolares y que la mayor concentración de la infromación esta en esta zona. Asimismo nos muestra que tenemos varios outliers con casas con valores muy altos.
*geom_jitter nos muestra la distribución de los datos en una grafica de puntos donde cada punto representa el valor de cada casa. Se crea una distorción minima para evitar que los datos hagan overlapping.

¿Qué observas en cada una de estas gráficas?

2. En la gráfica de las 14 variables mostrada arriba ¿Cómo describirías las distribuciones? 
  ¿Para cuales variables sería mejor utilizar `boxplot`? ¿Por qué?

  
Usando Boxplot queremos tener una mejor intuición sobre la distribución de los datos asi como como conocer la media y excluir los datos atipicos. Las variables de tax, nox e indus son buenos candidatos para este analisis data su stribución asimétrica. Es dificil saber sobre que valores se encuentran concentrdos estos datos, cual es su media y es muy psible que tengamos observaciones atípicas.

**Ejercicio 2** 
###Movies Data Set
1. ¿Qué puedes decir de esta gráfica?



```{r,  warning=FALSE}
ggplot(ggplot2movies::movies, aes(x=length)) + 
    xlim(0, 180) +
    geom_histogram(binwidth = 1) +
    xlab("Duración de películas en minutos") + ylab("") 
```



Tenemos dos concentraciones en los datos, una alrededor de los 15 minutos y otra cerca de los 80, 90 minutos. Esto sucede porque estamos considerando dos tipos de peliculas los corto metrajes y las producciones de pelicula. Cada distribucion parece ser normal con diferente media y una varianza mayor en el tipo peliculas.
2. ¿Cómo la modificas para agregar más *ticks*?
Usando breaks=seq(0, 150, by=.5) dentro de geom_histogram

```{r,  warning=FALSE}
ggplot(ggplot2movies::movies, aes(x=length)) + 
    xlim(0, 180) +
    geom_histogram(breaks=seq(0, 150, by=.5)) +
    xlab("Duración de películas en minutos") + ylab("")  
    #scale_x_continuous(breaks = seq(0,180,10))

```


3. Haz una gráfica que muestre que los picos a los 7 y 90 minutos existían antes y después de 1980

Se proponen diferentes soluciones usando colour, facet_grid y filtros.

```{r,  warning=FALSE}
data<-ggplot2movies::movies
data['is1980']<-data$year>1980
p=ggplot(data,   aes(x=length, colour=is1980))  
    p  + xlim(0, 180) + geom_histogram(binwidth = 1)  +xlab("Duración de películas en minutos despues de 1980") + ylab("")
    
p=ggplot(data, aes(length))
    p+ geom_bar() + xlim(0, 180) +  facet_grid(~ is1980 )
    
p=ggplot(data, aes(length, fill=factor(year)))
    p+ geom_bar() +  xlim(0, 180) 

p=ggplot(subset(data, year>=1980), aes(x=length))  
    p + xlim(0, 180) + geom_histogram(binwidth = 1) + xlab("Duración de películas en minutos despues de 1980") + ylab("") 
pp=ggplot(subset(ggplot2movies::movies, year<1980), aes(x=length))  
    pp + xlim(0, 180) + geom_histogram(binwidth = 1) + xlab("Duración de películas en minutos antes de 1980") + ylab("") 

```



4. Existe la variable `Short` que indica si la película es "corta" ¿Qué gráfica puedes  hacer para
   ver que criterio se utilizó para definir esta variable y cuáles están mal clasificadas?
* Para hacer un pequeño analisis primero obeservamos con colores las graficas mal clasificadas, despues utilizamos un filtro con condiciones. Queremos elegir las observaciones con short=1 pero cuya duración es mayor a 45 y las variables short=0 con duración menor a 45 minutos. 

```{r,  warning=FALSE}
data<-ggplot2movies::movies
x2<-seq(1, 58788)


p=ggplot(ggplot2movies::movies,   aes(length, fill=factor(Short)))  
    p + xlim(0, 200)+ ylim(0, 200) + geom_bar() +  xlab("Pelicula ID") + ylab("Duracion de la pelicula") 

p=ggplot(ggplot2movies::movies,   aes(x=x2, y=length, colour=Short))  
    p + xlim(0, 58788)+ ylim(0, 200) + geom_point() +  xlab("Pelicula ID") + ylab("Duracion de la pelicula") 

p=ggplot(subset(ggplot2movies::movies, Short>0 & length>45), aes( x=year, y=length,  label=as.character(title)))  
     p + xlim(1900, 2006)+ ylim(0, 200) + geom_point() +  xlab("Pelicula año") + ylab("Duracion de la pelicula")  + geom_text(size=2)
     

p=ggplot(subset(ggplot2movies::movies, Short<=0 & length<45), aes( x=year, y=length, label=as.character(title)))  
     p + xlim(1900, 2006)+ ylim(0, 200) + geom_point() +  xlab("Pelicula año") + ylab("Duracion de la pelicula")  + geom_text(size=2)

```
    



** Ejercicio 3 **
1. Agrega *alpha-blending* ¿Qué pasa con los  *outliers*? ¿Diferentes valores funcionan mejor?

* Cuando aumentamos el valor alpha vemos una mayor cantidad de puntos traslucidos señalandonos cuales valores podrian ser considerados outliers dado el criterio alpha
```{r,  warning=FALSE}

ggplot(ggplot2movies::movies, aes(votes, rating, alpha=.005)) + geom_point() + ylim(1,10)

ggplot(ggplot2movies::movies, aes(votes, rating, alpha=.2)) + geom_point() + ylim(1,10)

ggplot(ggplot2movies::movies, aes(votes, rating, alpha=70)) + geom_point() + ylim(1,10)
```

2. ¿Cómo se ve la gráfica si  remueves las películas con menos de 100 votos?
* Se eliminan valores extremos sobre las calificaciones y reduciomos el rango de y. Tambien es mas facil reconocer una distribución con concentración en los valores 5 y 7.5

```{r,  warning=FALSE}
data<-subset(ggplot2movies::movies,  votes>100)

ggplot(data, aes(votes, rating, alpha=.3)) + geom_point() + ylim(1,10)+ xlim(0,2000)

```

3. ¿Cómo si remueves todas las películas que tienen un *rating* arriba de 9?
* La gráfica se parece a la anterior porque existen muchas películas con calificaciones muy altas pero que fueron calificadas por pocas personas. Cuando pocas personas califican entonces es probable que su calificación sea mayor a la que realmente deberia tener.

```{r,  warning=FALSE}
data<-subset(ggplot2movies::movies,  rating<9)

ggplot(data, aes(votes, rating) ) + geom_point() + ylim(1,10)

```

###Cars93 Data Set
**Ejercicio 4**

- ¿Cuál es el *outlier* de la izquierda?

```{r,  warning=FALSE}
ggplot(MASS::Cars93, aes(Weight, MPG.city)) + geom_point() +
    geom_smooth(colour="green") + ylim(0,50)
```

El outlier es Civic, el carro mas confiable que podrías tener.

```{r,  warning=FALSE}
ggplot(MASS::Cars93, aes(Weight, MPG.city, label=as.character(Model))) + geom_point() +
    geom_smooth(colour="green") + ylim(0,50)+ geom_text()
```



###Boston Data Set
**Ejercicio 5**

```{r, fig.height=13, fig.width=13,   warning=FALSE}
MASS::Boston %>%
    select(-rad,-chas) %>%
    ggpairs(title="Boston Dataset", diag=list(continuos='density', axisLabels='none'))
```


1. ¿Cuáles están positivamente correlacionadas con `medv`?
* rm, dis, black

2. La variable `crim` (tasa de crímenes per cápita) tiene *scatterplots* con forma inusual,
  donde los valores más altos de `crim` sólo ocurren para una valor de la otra variable
  ¿Qué explicación le puedes dar?
 
* Los crimene se realizan en zonas especificas, si vemos la grafica de crim vs dis vermos que a una menor distancia encontramos amyor cantidad de crimenes percapita y una mayor concentracion de observaciones. Esto quiere decir que tenemos mayor crimenes y mayores observaciones en zonas cercanas a los centros (zonas) comerciales.
Las zonas comerciales deben tener caracteristicas en comun como numero de habitaciones(edificios), mayor edad, menor proporcion de zonas residenciales.
 
3. Hay varias formas en los *scatterplots*, escoge 5 y explica como las interpretas?


* dis vs zn: Vemos que hay zonas residenciales concentradas en dos partes, unas relativamente cerca de los centros comerciales y otra mucho mas alejada de los centros comerciales tal vez son las zonas residenciales.
* dis vs rm: meintras aumenta la distancia las personas pueden pagar casas con mayor numero de cuartos. Esto sucede porque los terrenos son mas baratos cuando están lejos de las zonas comerciales.
* nox vs indus: entre mayor sea la cantidad de non-reatail commerce mayor es la concentraciòn de contaminantes esto puede explicarse si los comercios de non-retail son productores o fabricas.
* age vs nox: Las zonas con mayor edad tambien son las zonas con mayor cantidad de non-retail commerce. Esto podría confirmar nuestro supuesto de que se tratan de zonas insdutriales y por lo tanto fueron establecidas mucho antes que las zonas comerciales o residenciales.


**Ejercicio 6**

- Usando el `Boston` *dataset* realice un `pcp`. Trate de resaltar las características que ha observado en los 
ejercicios anteriores. Piensa como le hiciste

```{r}
data<-MASS::Boston
data['grupos']<-cut_interval(data$medv, 4)
ggparcoord(data, columns = 1:7, groupColumn = "grupos", scale='center')
```


**Ejercicio 7**

Crea en tu carpeta las carpetas `german` y `algas`, dentro de ellas crea los archivos 
`00-load.R`, `01-prepare.R` y `02-clean.R` y `run.R`
En estos archivos pondrás, respectivamente el código para ejecutar los *pipelines* siguientes de los 
casos de estudio.


***


##German Data Set

Primero debemos cargar los metadata para poder trabajar con los nombre de las columnas y decodificar nuestros datos

```{r}
## German credit ---------------------------------------------------------------

## Nombres de columnas ---------------------------------------------------------
german_colnames <- c('Status of existing checking account',
                     'Duration in month',
                     'Credit history',
                     'Purpose',
                     'Credit amount',
                     'Savings account/bonds',
                     'Present employment since',
                     'Installment rate in percentage of disposable income',
                     'Personal status and sex',
                     'Other debtors / guarantors',
                     'Present residence since',
                     'Property',
                     'Age in years',
                     'Other installment plans',
                     'Housing',
                     'Number of existing credits at this bank',
                     'Job',
                     'Number of people being liable to provide maintenance for',
                     'Telephone',
                     'foreign worker',
                     'good_loan'
)

## Códigos ---------------------------------------------------------------------
german_codes <- list('A11'='... < 0 DM',
                     'A12'='0 <= ... < 200 DM',
                     'A13'='... >= 200 DM / salary assignments for at least 1 year',
                     'A14'='no checking account',
                     'A30'='no credits taken/all credits paid back duly',
                     'A31'='all credits at this bank paid back duly',
                     'A32'='existing credits paid back duly till now',
                     'A33'='delay in paying off in the past',
                     'A34'='critical account/other credits existing (not at this bank)',
                     'A40'='car (new)',
                     'A41'='car (used)',
                     'A42'='furniture/equipment',
                     'A43'='radio/television', 'A44'='domestic appliances', 'A45'='repairs',
                     'A46'='education', 'A47'='(vacation - does not exist?)',
                     'A48'='retraining', 'A49'='business', 'A410'='others', 'A61'='... < 100 DM',
                     'A62'='100 <= ... < 500 DM', 'A63'='500 <= ... < 1000 DM',
                     'A64'='.. >= 1000 DM', 'A65'='unknown/ no savings account',
                     'A71'='unemployed', 'A72'='... < 1 year', 'A73'='1 <= ... < 4 years',
                     'A74'='4 <= ... < 7 years', 'A75'='.. >= 7 years', 'A91'='male : divorced/separated',
                     'A92'='female : divorced/separated/married',
                     'A93'='male : single',
                     'A94'='male : married/widowed',
                     'A95'='female : single',
                     'A101'='none',
                     'A102'='co-applicant',
                     'A103'='guarantor', 'A121'='real estate',
                     'A122'='if not A121 : building society savings agreement/life insurance',
                     'A123'='if not A121/A122 : car or other, not in attribute 6',
                     'A124'='unknown / no property',
                     'A141'='bank', 'A142'='stores',  'A143'='none', 'A151'='rent', 'A152'='own',
                     'A153'='for free', 'A171'='unemployed/ unskilled - non-resident',
                     'A172'='unskilled - resident', 'A173'='skilled employee / official',
                     'A174'='management/ self-employed/highly qualified employee/ officer',
                     'A191'='none', 'A192'='yes, registered under the customers name',
                     'A201'='yes', 'A202'='no'
)

```


**Ejercicio 8**

- Crea una función `load` en `utils.R` en tu carpeta, que descargue, si y sólo si no existe
un archivo `german.rds`. Si no existe, descarga y guarda el archivo.

```{r}
loadGerman<-function()
{
    print('Cargando datos de German Data')
    tryCatch(
        {
            print('El archivo existe')
            data<-readRDS( 'german.rds')
            #Intentaremos llamar a nuestra archivo
            
            

        }
    , error=function(err)
        {
        print('El archivo sera descargado')
        german_url <- paste('http://archive.ics.uci.edu/ml',
                            '/machine-learning-databases/statlog',
                            '/german/german.data',
                            sep='')

        german_data <- read_delim(german_url,
                                  col_names=FALSE,
                                  delim = " ")
        print( head(german_data))
        saveRDS(german_data, 'german.rds')

        }
    )
}
```



```{r}
loadGerman()
german_data<-readRDS( 'german.rds')
colnames(german_data) <- german_colnames
german_data$good_loan <- as.factor(
                          ifelse(
                            german_data$good_loan == 1, 
                            'GoodLoan', 
                            'BadLoan'
                            )
                          )

```



**Ejercicio 9**
- Crea una función `german_decode` en un archivo `utils.R` dentro de tu carpeta, 
esta función debe de utilizar `german_codes` (en el archivo `metadata.R`) para 
decodificar los elementos  de todas las columnas (por ejemplo `A201` -> `yes`)

- Utiliza `dplyr` para decodificar todas las columnas de `german_data`



```{r}

german_decode<-function(german_data, german_codes)
{
    german_aux<-german_data
    gercolnames<-colnames(german_data)
    for(i in gercolnames )
    {
        print(i)
        for(j in names(german_codes))
        {
        german_aux[i][ german_aux[i]==j] <-german_codes[j]
        }

    }
    german_aux<-as.data.frame(german_aux)
    #Algunos valores regresaran como listas
    for(i in colnames(german_data))
    {
        german_aux[i]<-unlist(german_aux[i])

    }
    return(german_aux)

}

```

```{r}
german_data<- german_data %>% german_decode(german_codes)
head(german_data)
```



**Ejercicio 10**

- ¿Hay algo raro con los datos de préstamo?
* Las variables son cadenas de texto y no pueden ser graficadas o analizadas en el estado en el que se encuentran.
Algunas columna contienen mas de una variable por lo que es dificil saber el valor real de estas variables.
Algunas variables numéricas aparecen como texto.

- ¿Cuál crees que debería ser la distribución del resultado del 
  préstamo `Good_Loan` respecto a `Credit history`?
* Deberiamos encontrar una concentración diferente para los tipos de Credit history para los good loans y los bad loans, por ejemplo los bad loans deberían tener una mayor cantidad de delay in paying off in time o not existing credits.

- Grafícalo y comenta tus resultados.
```{R}
p<-ggplot(german_data, aes(good_loan, fill=as.factor(as.character(german_data$`Credit history`)) ))
p +  geom_bar(position="fill") + ylab("") + xlab("Composición de los prestamos") +scale_fill_discrete("Credit history")
```



* Como se muestra la composicion de los BadLoan y GoodLoan son muy similares pero podemos observar la principal diferencia se encuentra en que los Good Loan tienen una mayor proporcion de cuentas con otros creditos en otros bancos. Asimismo los BadLoan tiene una mayor numero de cuentas que no han pedido creditos o todos los creditos han sido pagados de manera irregular.

```{r}

german_clean_colnames<-function(german_colnames)
{
    for( i in 1:length(german_colnames ))
    {


        cadena<-strsplit(german_colnames[i], ' ' )[[1]]
        newName<-''
        if(!is.na(cadena))
        {
            
            for(j in cadena)
            {

                if(newName=='')
                {
                    newName<-j
                }
                else
                {
                newName<-paste( newName , j, sep = '_')
                }

            }
            german_colnames[i]<-newName
            print(german_colnames[i])
        }

        #------------- repetir con / ------


        cadena<-strsplit(german_colnames[i], '/' )[[1]]
        newName<-''
        if(!is.na(cadena))
        {


            for(j in cadena)
            {

                if(newName=='')
                {
                    newName<-j
                }
                else
                {
                newName<-paste( newName , j, sep= '_')
                }

            }
            german_colnames[i]<-newName
            print(german_colnames[i])
        }


    }
    return(german_colnames)
}

```

```{r, echo=FALSE }
german_colnames<-german_clean_colnames( german_colnames )
colnames(german_data)<-german_colnames
```
**Ejercicio 11**

Revisa `german_data` con `summary()`, reporta alguna anomalía.


```{r}
summary(german_data)
```


No hay anomalias, la unica observación es que podriamos transformar ciertas variables a un formato numerico para poder obtener estadisticas descrptivas como por ejemplo el Personal_status_and_Sex o Housing.

**Ejercicio 12**

Asegurar que el *dataset* esté en forma *tidy*. Guarda esto en `german-tidy.rds`

* Para que nuestro archivo este en formato tidy es necesario separar la variable Personal_status_and_Sex pues tenemos dos valores dentro de una misma columna

```{r}
cadena<-strsplit( german_data$Personal_status_and_sex, ':')

sex<-list()
status<-list()
for(i in cadena)
{
  
    sex<-append(sex, i[1])
    status<- append(status, i[2])
}

german_data['sex']<-sex
german_data['status']<-status
german_data$Personal_status_and_sex<-NULL


saveRDS(german_data, 'german-tidy.rds')

```
 
 
```{r}
head(  readRDS('german-tidy.rds')  )
```

***
##Algas Data Set

**Cargando Metadata**
```{r}
## Algas -----------------------------------------------------------------------

## Nombre de columnas ----------------------------------------------------------
algas_colnames <- c('season',
                    'river_size',
                    'fluid_velocity',
                    'max_PH',
                    'min_O2',
                    'Cl',
                    'NO3',
                    'NH4',
                    'oPO4',
                    'PO4',
                    'Chla',
                    paste('a', seq(1:7), sep="")
)

```

** Ejercicio 13**

- Repite los pasos realizados para `german.data` con `algas`
- No te olvides de remover los `_` en las variables `river_size` y `fluid_velocity`
- Revisa con `summary()`, reporta alguna anomalía.

```{r}

print('Cargando nombre de Columnas')
loadAlgas<-function()
{
    print('Cargando datos de German Data')
    tryCatch(
        {
            print('El archivo existe')
            data<-readRDS( 'algas.rds')
            #Intentaremos llamar a nuestra archivo
            
            

        }
    , error=function(err)
        {
        print('El archivo sera descargado')
        algas_url <- 'https://archive.ics.uci.edu/ml/machine-learning-databases/coil-mld/analysis.data'

        algas <- read_csv(algas_url, 
                  col_names = algas_colnames,
                  na = 'XXXXXXX')
        print( head(algas))
        saveRDS(algas, 'algas.rds')

        }
    )
}


#En el caso de algas no es necesario hacer un decode para los valores de las columnas

print('Modificando Nombre de Columnas')

algas_clean_colnames<-function(algas_colnames)
{
    for( i in 1:length(algas_colnames ))
    {


        cadena<-strsplit(algas_colnames[i], ' ' )[[1]]
        newName<-''
        if(!is.na(cadena))
        {
            
            for(j in cadena)
            {

                if(newName=='')
                {
                    newName<-j
                }
                else
                {
                newName<-paste( newName , j, sep = '_')
                }

            }
            algas_colnames[i]<-newName
            print(algas_colnames[i])
        }

        #------------- repetir con / ------


        cadena<-strsplit(algas_colnames[i], '/' )[[1]]
        newName<-''
        if(!is.na(cadena))
        {


            for(j in cadena)
            {

                if(newName=='')
                {
                    newName<-j
                }
                else
                {
                newName<-paste( newName , j, sep= '_')
                }

            }
            algas_colnames[i]<-newName
            print(algas_colnames[i])
        }


    }
    return(algas_colnames)
}


```

```{r, }
loadAlgas()
algas<-readRDS('algas.rds')
algas_colnames<-algas_clean_colnames(algas_colnames)
head(summary(algas))
```



¿Por qué la columna `NO3` **no** es numérica?
*  Porque tenemos algunas observaciones donde tenemos mas de un punto de los numeros. 


**Ejercicio 13**

- Es importante en la etapa de exploración, poder generar varias gráficas de manera automática 
  y simple para analizarlas visualmente y tener una idea de los datos. 
- Crea una función que genere los tipos de gráfica para cada par de variables del `data.frame` (en realidad es un `tibble`).
  Esta función debe de recibir dos parámetros, uno que indique si genera todas las combinaciones 
  de dos variables o recibe una lista de variables en las cuales generar las combinaciones.
- Guárdala en `utils.R`. 
- Crea en `03-eda.R` en ambas carpetas: `algas` y `german`.

**El siguiente Codigo guarda las graficas para dos tipo de variables, Discretas y continuas. Tambien contempla si el usuario esta agregando una lista o si se desea imrprimir y gusardar solo algunas variables.**

```{r}

graficasIniciales<-function( data, lista=NULL )
{
    cont=0
    variablesDiscretas<-list()
    variablesContinuas<-list()

    if(!is.null(lista))
    {
       print('-----Generando graficas para variables en lista')
        for(i in lista)#Comprobando nombres en lista
        {
            if(is.na(match(i, colnames(data))))
            {
                print(paste('VALOR DE LISTA NO VALIDO ', i, sep=''))
                return('NA')
            }
        }
        for(i in lista)
        {
            print(paste('Graficas individulaes de ', i))


            if(is.character(data[i][[1,1]]))
            {
                variablesDiscretas<-c(variablesDiscretas , i)
                plotx<-ggplot(data, aes(data[[i]])) +
                    geom_bar() + xlab(i)
                ggsave( paste(paste('Grafica_Barras_', i, sep=''),'.png', sep=''), plotx)
                print(plotx)
            }
            else
            {

                #Grafica de Densidad para variables continuas
                variablesContinuas<-c(variablesContinuas, i)
                plotx<-ggplot(data, aes(data[i])) +
                       geom_density() + geom_vline(   xintercept = mean(as.numeric(unlist(data[i])), na.rm=TRUE  )  ) + xlab(i)
                ggsave( paste(paste('Grafica_Densidad', i, sep=''),'.png', sep=''), plotx)
                print(plotx)
                cont=cont+1

                #Grafica Q-Q para variables continuas
                plotx<-ggplot(data, aes(sample=data[i])) + stat_qq()
                print(plotx)
                ggsave( paste(paste('Grafica_QQ_', i, sep=''),'.png', sep=''), plotx)
                cont=cont+1

                #Grafica Boxplot para variables continuas
                plotx<-ggplot(data, aes(i, data[i])) + geom_boxplot()
                print(plotx)
                ggsave( paste(paste('Grafica_Boxplot_', i, sep=''),'.png', sep=''), plotx)
                cont=cont+1
            }
        }
    }
    else
    {
        print('----- Generando graficas para todas las variables')
        for(i in colnames(data))#Comprobando nombres en lista
        {
            print(paste('Graficas individulaes de ', i))
            #Grafica distribucion con media

            if(is.character(data[i][[1,1]]))
            {
                #Grafica de Barras para Varibales Discretas
                variablesDiscretas<-c(variablesDiscretas , i)
                plotx<-ggplot(data, aes(data[[i]])) +
                    geom_bar() + xlab(i)
                print(plotx)
                ggsave( paste(paste('Grafica_Barras_', i, sep=''),'.png', sep=''), plotx)
                cont=cont+1

            }
            else
            {
                #Grafica de Densidad para variables continuas
                variablesContinuas<-c(variablesContinuas, i)
                plotx<-ggplot(data, aes(data[i])) +
                    geom_density() + geom_vline(   xintercept = mean(as.numeric(unlist(data[i])), na.rm=TRUE  )  ) + xlab(i)
                ggsave( paste(paste('Grafica_Densidad_', i, sep=''),'.png', sep=''), plotx)
                print(plotx)
                cont=cont+1

                #Grafica Q-Q para variables continuas
                plotx<-ggplot(data, aes(sample=data[i])) + stat_qq()
                print(plotx)
                ggsave( paste(paste('Grafica_QQ_', i, sep=''),'.png', sep=''), plotx)
                cont=cont+1

                #Grafica Boxplot para variables continuas
                plotx<-ggplot(data, aes(i, data[i])) + geom_boxplot()
                print(plotx)
                ggsave( paste(paste('Grafica_Boxplot_', i, sep=''),'.png', sep=''), plotx , width = 13, height = 13)
                cont=cont+1

            }

        }


    }
    data2<-NULL
    print(paste('VAR CONT: ', variablesContinuas))
    for(i in variablesContinuas)
    {
        
        if(is.null(data2))
        {
            data2<-data[i]
        }
        else
        {
            data2<-cbind(data2, data[i])
        }
    }
    
    if( length(variablesContinuas)>=2 )
    {
    print(   paste( paste( 'Existen ' , length(variablesContinuas) ), ' variables Continuas') )
    #Grafica GGPAIR
    plotx<-ggpairs(data2 )
    print(plotx)
    print('guardando')
    ggsave( paste(paste('Grafica_GGPairs_', i, sep=''),'.png', sep=''), plotx , width = 13, height = 13 )
    }
    else
    {
    print('No hay suficientes variables para GGpair')
    }
    return('NA')
}

```


```{r}
graficasIniciales(algas,colnames(algas)[c(3,4,5,6)] )

```



**Ejercicio 14**

- Genera un reporte para ambos conjuntos de datos el estado de los valores missing.
- Muestra la matriz de correlación faltante en una gráfica.
- ¿Qué puedes entender?

```{r}
print('Observaciones con NAs')
algas_con_NAs <- algas[!complete.cases(algas),]
head(algas_con_NAs)

print('Numero de NAs por Observacion')
apply(algas, 1, function(x) sum(is.na(x)))

print('Seleccion de variables con un numero de NAs mayor a X')
algas[apply(algas, 1, function(x) sum(is.na(x))) > 2,]


```

```{r}

indices_con_Nas<-function(data, num )
{
    if(num>= 1)
    {
        print('El criterio de eliminacion no puede ser mayor a uno')
        return(NULL)
    }
    else
    {
        indices<-colnames(data)
        longitud<-length( indices )
  
        indRechazar<-round(longitud*num)
        observacionesNA<-apply(algas, 1, function(x) sum(is.na(x)))
     
        #print(observacionesNA)
        indices<-observacionesNA > indRechazar
        return(indices)
    }
    
}
```

* Esta funcion regresa todas las observaciones que tienen un numero de NAs por observación mayores a una fracción del total de variables en el data Set

```{r}
#Observaciones con un numero de NA's mayor al 20% de las variables
indices_con_Nas(algas, .2)

```

**Ejercicio 15**

- Una estrategia es rellenar los valores faltantes con alguna medida de centralidad.
    - Media, mediana, moda, etc.
- Para variables distribuidas normalmente, esta opción es la mejor.
- Pero para variables *skewed*  o con *outliers* esta decisión puede ser desastrosa.
- Por lo tanto, esta estrategia no se debe de utilizar salvo una exploración previa de las variables.

#### Ejemplo

- ¿A qué variables le puedes de `algas` le puedes aplicar este procedimiento?
* De acuerdo a las siguiente graficas podemos ver que no todas las variables se comportan como una normal. En realidad sólo max_PH y min_O2 parecen tener una distribucion masomenos normal. En caso de elegir la media o la moda en los casos que no tienen distribución normal es probable que estemos tomando un valor que realmente no existe en la miuestra y por lo tanto es poco probable que exista en la realidad.

```{r}
for( i in colnames(algas))
{
   tryCatch(
    {
    print( ggplot(algas, aes( algas[i] ) ) + geom_density()  + xlab(i))
    
    }
    ,error=function(err)
    {
        print(paste( 'No se pudo graficar: ', i))
    })
}
```

- ¿Qué puedes decir de `german_data`?
* Al igual que con el data Set de Algas no tenemos muchas variables que se comporten con una distribucion normal por lo tanto tomar el valor central para sustituir a los varoles NA no seria una buena estrategia.
 En particular duration_in_month y number_of_existing_credits parecen tener dos concentraciones de datos con diferentes medias.
```{r}
for( i in colnames(german_data))
{
   tryCatch(
    {
    print( ggplot(german_data, aes( german_data[i] ) ) + geom_density()  + xlab(i))

    }
    ,error=function(err)
    {
        print(paste( 'No se pudo graficar: ', i))
        
    })
}
```

- A las variables que no se les puede aplicar, explica por qué no.
* Estas Variables no tienen  una distribución normal o uniforme por lo que elegir la media para sustituir los valores NA con este numero no nos daria una buena aproximación del valor real de estas variables.  Tomemos el caso extremo de una variable binaria, el promedio siempre estara entre 0 y 1 pero este promedio no necesariamente existe como una observación

- Esta decisión debe de ser reproducible, agrega a `utils.R` una función que impute 
en las variables con  `NAs` el valor central (`median` si es numérica, `moda` si es categórica).
La función debe de tener la siguiente firma:

```{r}
print('Texto adicional')
problematic_rows <- problems(algas)$row

algas[problematic_rows,] <- algas %>% 
    slice(problematic_rows) %>% 
    unite(col="all", -seq(1:6), sep = "/", remove=TRUE) %>%
    extract(all, into=c("NO3", "NH4", "resto"), regex="([0-9]*.[0-9]{5})([0-9]*.[0-9]*)/(.*)/NA", remove=TRUE) %>%
    separate(resto, into=names(algas)[9:18], sep="/", remove=TRUE)    


algas$NO3<- as.numeric(algas$NO3)
algas$NH4<-as.numeric(algas$NH4)
algas$oPO4<-as.numeric(algas$oPO4)
algas$PO4<-as.numeric(algas$PO4)
algas$Chla<-as.numeric(algas$Chla)
algas$a1<-as.numeric(algas$a1)
algas$a2<-as.numeric(algas$a2)
algas$a3<-as.numeric(algas$a3)
algas$a4<-as.numeric(algas$a4)
algas$a5<-as.numeric(algas$a5)
algas$a6<-as.numeric(algas$a6)
algas$a7<-as.numeric(algas$a7)

print('FUNCION IMPUTAR VALOR CENTRAL')
imputar_valor_central <- function(data, colnames)
{
    for(i in colnames)
    {
        if(is.numeric(data[[i]][1]) ||is.numeric(data[[i]][2]) ) #Valores numericos
        {
        print(paste('VALOR NUMERICO', i, sep=' ')) 
        print('DATA SET')
        print( data[[i]] )
        media <-mean( as.numeric(as.character( data[[i]])), na.rm = TRUE)
        print(media) 
        data[[i]][is.na(data[[i]])]<-media
        
        }
        else
        {   print('VALOR DISCRETO')
            moda<-''
            maximo<-0
            valores<-unique(data[[i]])
            
            #Print obtención de MODA
            print(valores)
            for(v in valores)
            {
                
                
                cont<-0
             for(j in 1:length(data[[i]]))
             {
                 #print(paste( paste( paste(paste(paste('Valor i: ', i), '  Valor j: '), j), '  Valor v: '  ), v))
                 #print(data[[i]][j])
                if(!is.na(data[[i]][j]) && !is.na(v) )
                {
                    #print(paste('value' , data[[i]][j] ) )
                     if(data[[i]][j]==v) 
                    {
                         cont=cont+1
                     }
                }
             }
             if(cont>maximo)
                 {
                 moda<-v
                 maximo<-cont
                 }
            }
            data[[i]][is.na(data[i])]<-moda
        }
    }
    return(data)
}




```


```{r}
index<-!complete.cases(algas)

algas[index,]
algas_central<-imputar_valor_central(algas, colnames(algas))

algas_central[index,]


```



**Ejercicio 16**
Crea una función que sustituya los `NAs` con el valor dado por la 
regresión lineal recién calculada (No automatices la regresión lineal) usando la
siguiente firma

```{r}
algas %>%
    select(-c(1:3)) %>%
    cor(use="complete.obs") %>%
    symnum()

imputar_valor_lm <- function(var_dependiente, var_independiente)
    {
    
    modelo<-lm(var_dependiente ~  var_independiente )
    intercepto<-modelo$coefficients[1]
    beta<-modelo$coefficients[2]
    
    lmResult <-intercepto + (beta*var_independiente[is.na(var_dependiente)])
    print(paste('Resultados Regresion  : ' , lmResult))
    
    
    var_dependiente[is.na(var_dependiente)]<-lmResult 
    return(var_dependiente)

    }
```

* Utilizando esta natriz podemos ver que podemos predecir el valor para PO4 utilizando las variables de Cl ya que ambas estan correlacionados y por lo tanto el valor de los coeficientes debe ser significativo. Podríamos usar oPO4 pero es probable que las variables tengan NA en las mismas posiciones y por lo tanto hacer regresiones no sería eficiente.

```{r}
index<-is.na(algas$PO4)
cat('\nValores Vacios')
algas$PO4[index]

algas_lm<-algas
algas_lm$PO4 <-imputar_valor_lm(algas_lm$PO4, algas$Cl)
cat('\n\nValores Calculados\n')
algas_lm$PO4[index]


```

